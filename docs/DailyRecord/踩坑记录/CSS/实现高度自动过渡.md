---
outline: [2, 6]
tag: ['transition', 'css', '踩坑记录', '语法']
---

# 高度自动过渡
几乎每个前端都会遇到这么一个问题：如何在一个高度自动的区域实现下拉过渡效果？


## transition无法过渡的情况
我们知道，过渡属性`transition`需要属性有确定的值才能过渡，详情请看我的另一篇文章[关于transition属性](../../../Front-end/CSS相关/transition过渡属性.md)

- 假设有一个区域，高度是`fit-content`，即内容高度自适应，是一个计算值，那么过渡属性`transition`无法过渡，因为`transition`需要属性有确定的值才能过渡。
```vue:demo
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 overflow-hidden">
  <div class="box flex flex-col bg-gray-300 dark:bg-gray-800 rounded-lg ">
    <div class="content">fit-content无法过渡fit-content无法过渡fit-content无法过渡fit-content无法过渡fit-content无法过渡fit-content无法过渡fit-content无法过渡fit-content无法过渡fit-content无法过渡    
    </div>
  </div>
</div>
</template>
<style scoped>
.box {
  height: 100px;
  transition: 0.5s;
}
.box:hover {
  height: fit-content;
}
</style>
```

- 假设有一个区域，高度是`auto`，那么过渡属性`transition`无法过渡，因为`auto`是自适应高度，是一个计算值，不是确定的值。
```vue:demo
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 overflow-hidden">
  <div class="box flex flex-col bg-gray-300 dark:bg-gray-800 rounded-lg ">
    <div class="content">auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡auto无法过渡   
    </div>
  </div>
</div>
</template>
<style scoped>
.box {
  height: 100px;
  transition: 0.5s;
}
.box:hover {
  height: auto;
}
</style>
```

- 假设是最大高度`max-height`，我们把变化后的最大高度设为一个很大的值，这至少算个确定的值吧？
```vue:demo
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 overflow-hidden">
  <div class="box flex flex-col bg-gray-300 dark:bg-gray-800 rounded-lg ">
    <div class="content">max-height可以过渡max-height可以过渡max-height可以过渡max-height可以过渡max-height可以过渡max-height可以过渡max-height可以过渡max-height可以过渡max-height可以过渡max-height可以过渡
    </div>
  </div>
</div>
</template>
<style scoped>
.box {
  max-height: 100px;
  transition: 2.5s;
}
.box:hover {
  max-height: 1000px;
}
</style>
```

> 看起来生效了，难道这就完美解决了？

::: danger 然而最大高度也是一种错误的实现方案
为什么？？？
:::

因为**在过渡应用在最大高度时，不论内容大小，过渡的时间总是按最大高度计算，而不是按内容自动高度计算**，这就会导致一种情况：

- 内容高度远小于最大高度时，过渡时间过长；内容高度远超出最大高度时，过渡时间过短。

![](https://cdn.jsdelivr.net/gh/Dantezhenniubi/image-repo@master/%E9%AB%98%E5%BA%A6%E8%BF%87%E6%B8%A1%E5%8E%9F%E7%90%86.png)
这是一个便于理解的演示图，红色是最大高度，蓝色是自动高度。<br>
**当鼠标移入，展开时，由于过渡时间是按最大高度算，但是可见部分只有蓝色部分，所以用户会感觉过渡很快，因为只走了过渡的一部分(绿色箭头)。**<br>
**当鼠标移开，收回时，由于过渡时间是按最大高度算，所以会走完整个紫色箭头部分，用户会感觉先停顿，然后才开始收起，同样的，收起也会比预想的要快。**<br>

我们来看一个很明显的例子，把过渡时间设为一个很大的值(方便你理解)，你可以试着移入鼠标展开，然后移开鼠标，**鼠标移开后不会马上收回，而是等过渡完成后才会收回**。
```vue:demo
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 overflow-hidden">
  <div class="box flex flex-col bg-gray-300 dark:bg-gray-800 rounded-lg ">
    <div class="content">错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡错误的过渡
    </div>
  </div>
</div>
</template>
<style scoped>
.box {
  max-height: 100px;
  transition: 6.5s;
}
.box:hover {
  max-height: 1000px;
}
</style>
```
很显然，这并不符合我们的设计初衷。我们期望的是，内容高度变化时，过渡时间根据内容高度变化，而不是根据最大高度变化。

## 常规思路
最常规的思路，便是用JS来实现，因为纯CSS已经不能满足要求了。<br>
这里因为demo展示只能展示vue组件，先展示一下js的思路，一会展示vue组件的写法
```html
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 overflow-hidden">
  <div class="JSbox">
    <div class="content">JS实现高度自动过渡JS实现高度自动过渡JS实现高度自动过渡JS实现高度自动过渡JS实现高度自动过渡JS实现高度自动过渡JS实现高度自动过渡JS实现高度自动过渡JS实现高度自动过渡JS实现高度自动过渡JS实现高度自动过渡
    </div>
  </div>
</div>
</template>
<script setup>
// 拿到box元素
const JSbox = document.querySelector('.JSbox');
// 注册一个鼠标移入事件
JSbox.onmouseenter = () => {
  // 首先把高度设置为auto(这一步是为了拿到高度)
  JSbox.style.height = 'auto';
  // 拿到高度
  const h = JSbox.offsetHeight;
  // 还原高度(因为渲染线程是单线程，所以不会马上渲染，而是等JS执行完毕)
  JSbox.style.height = '100px';
  // 读元素几何位置信息，触发强制渲染(浏览器渲染管线的layout reflow回流)
  JSbox.clientHeight;
  // 设置过渡
  JSbox.style.transition = '6.5s';
  // 设置为确定高度
  JSbox.style.height = h + 'px';
}
</script>
<style scoped>
.JSbox {
  height: 100px;
}
</style>
```

上面的写法虽然逻辑正确，但是这么写在vue组件里是不行的。
- 直接执行 DOM 查询时，Vue 组件可能还没有渲染完成
```js
// ❌ 错误：组件渲染前执行，此时DOM还不存在
const box = document.querySelector('.box');
```


在Vue中，直接操作DOM并不是一个推荐的做法，主要是因为Vue的设计初衷是为了简化DOM操作和提高开发效率。Vue通过使用虚拟DOM（Virtual DOM）和响应式系统，使得开发者可以更高效地更新UI而无需直接与DOM打交道。

我们应当避免直接操作DOM，而是使用模板引用和响应式数据来实现类似效果。

- 使用Vue的ref属性替代document.querySelector来获取DOM元素引用
- 通过@mouseenter和@mouseleave事件绑定替代直接的事件处理赋值
- 将JavaScript逻辑封装在Vue组件的setup函数中

下面展示一下vue组件的写法
```vue:demo
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 overflow-hidden">
  <div 
    ref="boxRef"
    class="box flex flex-col bg-gray-300 dark:bg-gray-800 rounded-lg transition-all duration-6500"
    @mouseenter="expand"
    @mouseleave="collapse"
  >
    <div class="content">Vue实现高度自动过渡Vue实现高度自动过渡Vue实现高度自动过渡Vue实现高度自动过渡Vue实现高度自动过渡Vue实现高度自动过渡Vue实现高度自动过渡Vue实现高度自动过渡Vue实现高度自动过渡Vue实现高度自动过渡Vue实现高度自动过渡
    </div>
  </div>
</div>
</template>

<script setup>
import { ref } from 'vue'

/* 1. 拿到元素引用 */
const boxRef = ref(null)
const isExpand = ref(false)

/* 2. 缓存原始高度（仅记录一次即可） */
let baseHeight = 0

/* 3. 展开：auto → 具体值 */
function expand() {
  const el = boxRef.value
  if (!el) return

  /* 首次进入时记录原始高度 */
  if (!baseHeight) baseHeight = el.offsetHeight

  /* 让浏览器先算出“自然高度” */
  el.style.height = 'auto'
  const target = el.offsetHeight

  /* 立刻回到原始高度，触发重排 */
  el.style.height = baseHeight + 'px'
  void el.offsetHeight   // force reflow

  /* 再过渡到目标高度 */
  el.style.transition = 'height .65s'
  el.style.height = target + 'px'
}

/* 4. 收起：回到原始高度 */
function collapse() {
  const el = boxRef.value
  if (!el) return
  el.style.height = baseHeight + 'px'
}
</script>

<style scoped>
.box {
  height: 50px;
  overflow: hidden;
  line-height: 1.5; 
}
</style>

```

既然我们已经实现，那能不能在未变化时给文字加省略号呢？

```vue:demo
<template>
  <div
    ref="boxRef"
    class="box"
    :class="{ expand: isExpand }"
    @mouseenter="expand"
    @mouseleave="collapse"
  >
    <div class="content">
      Vue 实现高度自适应过渡，文字可多行，鼠标移入展开，移出收起并恢复省略号。Vue 实现高度自适应过渡，文字可多行，鼠标移入展开，移出收起并恢复省略号。Vue 实现高度自适应过渡，文字可多行，鼠标移入展开，移出收起并恢复省略号。Vue 实现高度自适应过渡，文字可多行，鼠标移入展开，移出收起并恢复省略号。Vue 实现高度自适应过渡，文字可多行，鼠标移入展开，移出收起并恢复省略号。Vue 实现高度自适应过渡，文字可多行，鼠标移入展开，移出收起并恢复省略号。Vue 实现高度自适应过渡，文字可多行，鼠标移入展开，移出收起并恢复省略号。
    </div>
  </div>
</template>

<script setup>
import { ref, nextTick } from 'vue'

const boxRef = ref(null)
const isExpand = ref(false)

let baseHeight = 0
let fullHeight = 0
let initDone = false

async function initSize () {
  if (initDone) return
  const el = boxRef.value
  if (!el) return

  /* 1. 先让浏览器按省略号排版 */
  isExpand.value = false
  await nextTick()
  baseHeight = el.scrollHeight          // 3 行真实高度

  /* 2. 再测完整内容高度 */
  isExpand.value = true
  await nextTick()
  fullHeight = el.scrollHeight

  /* 3. 初始化完成：把高度锁到 baseHeight，后面全靠行内 height 做动画 */
  el.style.height = baseHeight + 'px'
  isExpand.value = false
  void el.offsetHeight          // ← 强制重排，让浏览器先渲染这一帧
  initDone = true
}

async function expand () {
  await initSize()
  const el = boxRef.value
  el.style.transition = 'height .45s'
  el.style.height = fullHeight + 'px'
  isExpand.value = true
}

async function collapse () {
  await initSize()
  const el = boxRef.value
  el.style.transition = 'height .45s'
  el.style.height = baseHeight + 'px'
  isExpand.value = false
}
</script>

<style scoped>
.box {
  width: 280px;
  overflow: hidden;
  background: #f3f4f6;
  border-radius: 8px;
  padding: 12px;
  line-height: 1.5;
  cursor: pointer;
}

/* 省略号：3 行 */
.content {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
  overflow: hidden;
}

/* 展开时取消省略号 */
.expand .content {
  -webkit-line-clamp: unset;
}
</style>
```

- `:class="{ expand: isExpand }"` 是 Vue 的「对象语法」绑定方式
- 当 `isExpand === true` 时，给元素加上类名 `expand`；否则不加。

拆开看：
- `:class` 是 `v-bind:class` 的简写，用来动态绑定 CSS 类。
- 对象语法 `{ expand: isExpand }`
- 键 `expand` 是要加的类名（可任意取名）。
- 值 `isExpand` 是布尔变量，为 true 时类名生效，为 false 时移除。

## 新的CSS实现方式
有没有办法实现这种过渡效果，又不使用JS呢？

有，但是兼容性不是很好。

如果你做的是带有内置浏览器内核的一些应用，比如像一些桌面端electron，只要内置的浏览器支持那就没问题，其它情况还是得斟酌处理。
### 使用新属性

涉及到新的CSS属性：`interpolate-size`尺寸差值，在过渡期间通过差值算法计算出过渡过程中的尺寸值。

- `interpolate-size: allow-keywords` 允许使用关键字 `auto` 进行过渡。
- `interpolate-size: none` 禁用尺寸差值过渡，仅使用静态尺寸值。
- `interpolate-size: auto` 自动根据尺寸值类型选择过渡方式。如果尺寸值为 `auto`，则使用 `allow-keywords`；否则使用 `none`。
- `interpolate-size: inherit` 从父元素继承过渡方式。
- `interpolate-size: initial` 使用浏览器默认值。
- `interpolate-size: unset` 移除尺寸差值过渡，使用静态尺寸值。
- `interpolate-size: numeric-only` 仅对数值尺寸值启用差值过渡，对关键字尺寸值禁用。

我们来看看**允许关键字过渡**的效果：

`fit-content`适应内容高度
```vue:demo
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 overflow-hidden">
  <div class="box flex flex-col bg-gray-300 dark:bg-gray-800 rounded-lg ">
    <div class="content">适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度适应内容高度   
    </div>
  </div>
</div>
</template>
<style scoped>
.box {
  height: 100px;
  transition: 0.5s;
  interpolate-size: allow-keywords;
}
.box:hover {
  height: fit-content;
}
</style>
```

`auto`自动高度
```vue:demo
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 overflow-hidden">
  <div class="box flex flex-col bg-gray-300 dark:bg-gray-800 rounded-lg ">
    <div class="content">自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度自动高度   
    </div>
  </div>
</div>
</template>
<style scoped>
.box {
  height: 100px;
  transition: 0.5s;
  interpolate-size: allow-keywords;
}
.box:hover {
  height: auto;
}
</style>
```
`max-content`最大内容高度
```vue:demo
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 overflow-hidden">
  <div class="box flex flex-col bg-gray-300 dark:bg-gray-800 rounded-lg ">
    <div class="content">最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度最大内容高度  
    </div>
  </div>
</div>
</template>
<style scoped>
.box {
  height: 100px;
  transition: 0.5s;
  interpolate-size: allow-keywords;
}
.box:hover {
  height: max-content;
}
</style>
```

### 使用新函数
`calc-size()`这个也是一个比较新的计算函数，可以把`auto`这些变成数值进行过渡。

同样需要注意兼容性问题。

第一个参数是要计算的关键字，结果会保存到第二个变量比如size中，你可以基于这个变量进一步运算，比如`height: calc-size(auto, size / 2);` `height: calc-size(auto, size + 10px);`

```vue:demo
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4 overflow-hidden">
  <div class="box flex flex-col bg-gray-300 dark:bg-gray-800 rounded-lg ">
    <div class="content">计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数计算函数 
    </div>
  </div>
</div>
</template>
<style scoped>
.box {
  height: 100px;
  transition: 0.5s;
}
.box:hover {
  height: calc-size(auto, size);
}
</style>
```




## 题外话：

这是一种使用`max-height`的省略号的实现方式，是一开始不懂时乱搞的，不过如果内容较少，用这种方式感觉也未尝不可，因为造成的影响几乎无感知

直接用两份文字交替覆盖，虽然还是有些瑕疵。。。
```vue:demo
<template>
<div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4">
  <div class="group flex flex-col bg-gray-300 dark:bg-gray-800 rounded-lg
              min-h-[7rem] max-h-[7rem] hover:max-h-[30rem]
              transition-[max-height] duration-300 ease-in-out overflow-hidden">

    <h5 class="px-4 pt-4 text-base font-semibold">我是标题</h5>

    <!-- 文字容器 -->
    <div class="relative px-4 pb-4 text-sm text-gray-500 dark:text-gray-400
                max-h-[2.6em] group-hover:max-h-[60em]
                transition-[max-height] duration-300 ease-in-out overflow-hidden">
      <!-- 上层：单行 + 省略号 -->
      <div class="absolute inset-0 left-4 right-4
                  opacity-100 group-hover:opacity-0 line-clamp-2">
        这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述
      </div>

      <!-- 下层：全文 -->
      <div class="opacity-0 group-hover:opacity-100">
        这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述这是一段足够长的描述
      </div>
    </div>
  </div>
</div>
</template>
```