

## 完整封装示例
下面给出示例代码，我们对每一处代码进行分析

```vue
<!-- BackTop.vue -->
<template>
  <transition
    :name="animation"
    appear
    @before-enter="emit('beforeShow')"
    @after-enter="emit('afterShow')"
    @before-leave="emit('beforeHide')"
    @after-leave="emit('afterHide')"
  >
    <div
      v-if="visible"
      class="back-top"
      :class="positionClass"
      :style="rootStyle"
      @click="scrollToTop"
    >
      <div class="progress-ring" :style="ringStyle">
        <div class="back-top-inner" :style="innerStyle">
          <slot name="icon" v-if="showArrow">
            <!-- 默认箭头 -->
            <svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M12 5v14M19 12l-7 7-7-7" />
            </svg>
          </slot>
          <slot v-else />
        </div>
      </div>
    </div>
  </transition>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onBeforeUnmount, type StyleValue } from 'vue';

/* ---------------- Props + Emits ---------------- */
interface Props {
  visibilityHeight?: number;
  duration?: number;
  progressColor?: string;
  size?: number | string;
  target?: string | Element;
  position?: 'left' | 'right';
  offset?: [number, number];
  animation?: 'fade' | 'slide-up' | 'slide-down' | 'scale';
  showArrow?: boolean;
}
const props = withDefaults(defineProps<Props>(), {
  visibilityHeight: 400,
  duration: 500,
  progressColor: '#409eff',
  size: 40,
  target: undefined,
  position: 'right',
  offset: () => [30, 30],
  animation: 'fade',
  showArrow: true,
});

const emit = defineEmits<{
  beforeShow: [];
  afterShow: [];
  beforeHide: [];
  afterHide: [];
}>();

/* ---------------- 响应式数据 ---------------- */
const visible = ref(false);
const scrollPercent = ref(0);

/* ---------------- 计算属性 ---------------- */
const progressNum = computed(() => Math.min(100, Math.max(0, scrollPercent.value)));

const rootStyle = computed<StyleValue>(() => ({
  width: `${props.size}px`,
  height: `${props.size}px`,
}));

const ringStyle = computed<StyleValue>(() => ({
  background: `conic-gradient(${props.progressColor} ${progressNum.value}% , transparent ${progressNum.value}%)`,
}));

const innerStyle = computed<StyleValue>(() => ({
  width: `calc(${props.size}px - 8px)`,
  height: `calc(${props.size}px - 8px)`,
}));

const positionClass = computed(() => `pos-${props.position}`);

/* ---------------- 滚动相关 ---------------- */
let el: Element | Window = window;

function getScrollTop() {
  if (el === window) return window.pageYOffset || document.documentElement.scrollTop;
  return (el as Element).scrollTop;
}

function getScrollHeight() {
  if (el === window) return document.documentElement.scrollHeight;
  return (el as Element).scrollHeight;
}

function getClientHeight() {
  if (el === window) return window.innerHeight;
  return (el as Element).clientHeight;
}

function handleScroll() {
  const scrollTop = getScrollTop();
  const scrollHeight = getScrollHeight();
  const clientHeight = getClientHeight();
  const maxScroll = scrollHeight - clientHeight;

  scrollPercent.value = maxScroll > 0 ? (scrollTop / maxScroll) * 100 : 0;
  visible.value = scrollTop >= props.visibilityHeight;
}

function scrollToTop() {
  const startTime = performance.now();
  const startTop = getScrollTop();

  const animate = (now: number) => {
    const elapsed = now - startTime;
    const progress = Math.min(elapsed / props.duration, 1);
    const easeOut = 1 - Math.pow(1 - progress, 3);
    const newTop = startTop * (1 - easeOut);

    if (el === window) window.scrollTo(0, newTop);
    else (el as Element).scrollTop = newTop;

    if (progress < 1) requestAnimationFrame(animate);
  };

  requestAnimationFrame(animate);
}

/* ---------------- 生命周期 ---------------- */
onMounted(() => {
  const target = props.target;
  if (target && typeof target === 'string') el = document.querySelector(target) || window;
  else if (target instanceof Element) el = target;

  handleScroll();
  el.addEventListener('scroll', handleScroll, { passive: true });
});

onBeforeUnmount(() => {
  el.removeEventListener('scroll', handleScroll);
});
</script>

<style scoped>
/* ===== 基础定位 ===== */
.back-top {
  position: fixed;
  bottom: v-bind('offset[1] + "px"');
  z-index: 1000;
  cursor: pointer;
}
.back-top.pos-right {
  right: v-bind('offset[0] + "px"');
}
.back-top.pos-left {
  left: v-bind('offset[0] + "px"');
}

/* ===== 圆环 + 内圆 ===== */
.progress-ring {
  width: v-bind('size + "px"');
  height: v-bind('size + "px"');
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
.back-top-inner {
  border-radius: 50%;
  background: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  transition: all 0.3s ease;
}
.back-top-inner:hover {
  transform: scale(1.05) rotate(180deg);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* ===== 动画 ===== */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}
.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

.slide-up-enter-active,
.slide-up-leave-active {
  transition: all 0.3s ease;
}
.slide-up-enter-from {
  transform: translateY(30px);
  opacity: 0;
}
.slide-up-leave-to {
  transform: translateY(30px);
  opacity: 0;
}

.slide-down-enter-active,
.slide-down-leave-active {
  transition: all 0.3s ease;
}
.slide-down-enter-from {
  transform: translateY(-30px);
  opacity: 0;
}
.slide-down-leave-to {
  transform: translateY(-30px);
  opacity: 0;
}

.scale-enter-active,
.scale-leave-active {
  transition: all 0.3s ease;
}
.scale-enter-from {
  transform: scale(0);
  opacity: 0;
}
.scale-leave-to {
  transform: scale(0);
  opacity: 0;
}
</style>
```

## 代码解析

### 模板部分
::: CTcode
```vue{2,11}
<template>
  <transition
    :name="animation"
    appear
    @before-enter="emit('beforeShow')"
    @after-enter="emit('afterShow')"
    @before-leave="emit('beforeHide')"
    @after-leave="emit('afterHide')"
  >
  .........
  </transition>
</template>
```
Vue 内置抽象组件，不会渲染额外 DOM；只负责在子元素进入/离开时自动加 CSS 类名并触发钩子。
:::
::: CTcode
```vue{3}
<template>
  <transition
    :name="animation"
    appear
    @before-enter="emit('beforeShow')"
    @after-enter="emit('afterShow')"
    @before-leave="emit('beforeHide')"
    @after-leave="emit('afterHide')"
  >
  .........
  </transition>
</template>
```
动态绑定过渡类名前缀，例如 `animation="slide-up"` → 实际类名是 `slide-up-enter-from` 等。总共有四个动画选项：`fade`、`slide-up`、`slide-down`、`scale`。
:::
::: CTcode
```vue{4}
<template>
  <transition
    :name="animation"
    appear
    @before-enter="emit('beforeShow')"
    @after-enter="emit('afterShow')"
    @before-leave="emit('beforeHide')"
    @after-leave="emit('afterHide')"
  >
  .........
  </transition>
</template>
```
让元素第一次渲染时就执行过渡（否则只在 v-if 切换时才执行）
:::
::: CTcode
```vue{5-8}
<template>
  <transition
    :name="animation"
    appear
    @before-enter="emit('beforeShow')"
    @after-enter="emit('afterShow')"
    @before-leave="emit('beforeHide')"
    @after-leave="emit('afterHide')"
  >
  .........
  </transition>
</template>
```
把过渡生命周期原样暴露给父组件，方便数据埋点、连锁动画。
:::
::: CTcode
```vue{2}
<div
  v-if="visible"
  class="back-top"
  :class="positionClass"
  :style="rootStyle"
  @click="scrollToTop"
>
......
</div>
```
真正渲染的按钮根节点；`visible` 是滚动距离计算出的布尔值。
`visible.value = scrollTop >= props.visibilityHeight;`判断滚动距离是否大于等于阈值，大于等于则显示按钮，否则隐藏按钮。
:::

::: CTcode
```vue{4}
<div
  v-if="visible"
  class="back-top"
  :class="positionClass"
  :style="rootStyle"
  @click="scrollToTop"
>
......
</div>
```
计算属性返回 `pos-left` 或 `pos-right`，用于决定水平定位（left/right）。

```const positionClass = computed(() => `pos-${props.position}`);```

对应后面的样式
```css
.back-top.pos-right {
  right: v-bind('offset[0] + "px"');
}
.back-top.pos-left {
  left: v-bind('offset[0] + "px"');
}
```
:::

::: CTcode
```vue{5}
<div
  v-if="visible"
  class="back-top"
  :class="positionClass"
  :style="rootStyle"
  @click="scrollToTop"
>
......
</div>
```
动态设置按钮整体宽高（由 size prop 决定）。
:::

::: CTcode
```vue{6}
<div
  v-if="visible"
  class="back-top"
  :class="positionClass"
  :style="rootStyle"
  @click="scrollToTop"
>
......
</div>
```
点击后执行平滑回顶逻辑（自实现 RAF + easeOut）。
:::

::: CTcode
```vue{8,25}
<div
  v-if="visible"
  class="back-top"
  :class="positionClass"
  :style="rootStyle"
  @click="scrollToTop"
>
  <div class="progress-ring" :style="ringStyle">
    <div class="back-top-inner" :style="innerStyle">
      <slot name="icon" v-if="showArrow">
        <!-- 默认箭头 -->
        <svg
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <path d="M12 5v14M19 12l-7 7-7-7" />
        </svg>
      </slot>
      <slot v-else />
    </div>
  </div>
</div>
```
圆环背景；`ringStyle` 用 `conic-gradient` 做进度色环，百分比实时变。
```css
const ringStyle = computed<StyleValue>(() => ({
  background: `conic-gradient(${props.progressColor} ${progressNum.value}% , transparent ${progressNum.value}%)`,
}));
```
:::

::: CTcode
```vue{9,24}
<div
  v-if="visible"
  class="back-top"
  :class="positionClass"
  :style="rootStyle"
  @click="scrollToTop"
>
  <div class="progress-ring" :style="ringStyle">
    <div class="back-top-inner" :style="innerStyle">
      <slot name="icon" v-if="showArrow">
        <!-- 默认箭头 -->
        <svg
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <path d="M12 5v14M19 12l-7 7-7-7" />
        </svg>
      </slot>
      <slot v-else />
    </div>
  </div>
</div>
```
内圆白底，hover 放大 + 旋转 180°；里面放箭头或自定义插槽。
```css
const innerStyle = computed<StyleValue>(() => ({
  width: `calc(${props.size}px - 8px)`,
  height: `calc(${props.size}px - 8px)`,
}));
```
:::

::: CTcode
```vue{10-23}
<div
  v-if="visible"
  class="back-top"
  :class="positionClass"
  :style="rootStyle"
  @click="scrollToTop"
>
  <div class="progress-ring" :style="ringStyle">
    <div class="back-top-inner" :style="innerStyle">
      <slot name="icon" v-if="showArrow">
        <!-- 默认箭头 -->
        <svg
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <path d="M12 5v14M19 12l-7 7-7-7" />
        </svg>
      </slot>
      <slot v-else />
    </div>
  </div>
</div>
```
如果用户没关箭头，就渲染默认向下箭头；否则整块插槽交给用户。
:::

### script部分

#### 类型与默认值：

| 代码                                        | 说明                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| `interface Props { … }`                     | 定义 9 个可选 prop 及其类型，**IDE 自动提示 + 运行时校验**。 |
| `withDefaults(defineProps<Props>(), { … })` | 为每个 prop 提供**默认值**，同时保持类型推导。               |

#### 响应式数据

| 代码                           | 说明                                      |
| ------------------------------ | ----------------------------------------- |
| `const visible = ref(false)`   | 控制按钮**显示/隐藏**。                   |
| `const scrollPercent = ref(0)` | 当前滚动百分比（0-100），用于**进度环**。 |

#### 计算属性

::: CTcode
```ts
const progressNum = computed(() => Math.min(100, Math.max(0, scrollPercent.value)));
```
把 `scrollPercent`(当前滚动百分比) 钳制在 0-100，避免超界。
:::

::: CTcode
```ts
const rootStyle = computed<StyleValue>(() => ({
  width: `${props.size}px`,
  height: `${props.size}px`,
}));
```
返回 `{width: xx, height: xx}`，动态尺寸来源 size prop。
:::

::: CTcode
```ts
const ringStyle = computed<StyleValue>(() => ({
  background: `conic-gradient(${props.progressColor} ${progressNum.value}% , transparent ${progressNum.value}%)`,
}));
```
圆锥渐变背景，百分比实时变 → 形成「圆环进度条」。
:::

::: CTcode
```ts
const innerStyle = computed<StyleValue>(() => ({
  width: `calc(${props.size}px - 8px)`,
  height: `calc(${props.size}px - 8px)`,
}));
```
内圆比外环小 8 px，居中显示。
:::

::: CTcode
```ts
const positionClass = computed(() => `pos-${props.position}`);
```
返回 `pos-left` 或 `pos-right`，决定固定在左还是右。
:::

#### 滚动核心工具函数

::: CTcode 统一处理 window 与 局部元素 的滚动度量
```ts
function getScrollTop() {
  if (el === window) return window.pageYOffset || document.documentElement.scrollTop;
  return (el as Element).scrollTop;
}

function getScrollHeight() {
  if (el === window) return document.documentElement.scrollHeight;
  return (el as Element).scrollHeight;
}

function getClientHeight() {
  if (el === window) return window.innerHeight;
  return (el as Element).clientHeight;
}
```
:::

::: CTcode 计算滚动百分比
```ts
function handleScroll() {
  const scrollTop = getScrollTop();
  const scrollHeight = getScrollHeight();
  const clientHeight = getClientHeight();
  const maxScroll = scrollHeight - clientHeight;

  scrollPercent.value = maxScroll > 0 ? (scrollTop / maxScroll) * 100 : 0;
  visible.value = scrollTop >= props.visibilityHeight;
}
```
:::

::: CTcode RAF + easeOut 三次方曲线，时间可控（duration prop），支持局部容器
```ts
function scrollToTop() {
  const startTime = performance.now();
  const startTop = getScrollTop();

  const animate = (now: number) => {
    const elapsed = now - startTime;
    const progress = Math.min(elapsed / props.duration, 1);
    const easeOut = 1 - Math.pow(1 - progress, 3);
    const newTop = startTop * (1 - easeOut);

    if (el === window) window.scrollTo(0, newTop);
    else (el as Element).scrollTop = newTop;

    if (progress < 1) requestAnimationFrame(animate);
  };

  requestAnimationFrame(animate);
}
```
:::

#### 生命周期

::: CTcode 解析 target prop（支持字符串选择器或 DOM 对象），绑定滚动监听。
```ts
onMounted(() => {
  // target不传递时默认以window计算滚动百分比
  const target = props.target;
  if (target && typeof target === 'string') el = document.querySelector(target) || window;
  else if (target instanceof Element) el = target;
  // 调用计算滚动百分比
  handleScroll();
  // 绑定滚动监听，参数passive的意思是告诉浏览器不要阻塞滚动事件，而是在事件处理完成后再滚动
  el.addEventListener('scroll', handleScroll, { passive: true });
});
```
:::

::: 组件销毁时移除监听，防止内存泄漏
```ts
onBeforeUnmount(() => {
  el.removeEventListener('scroll', handleScroll);
});
```
:::

### 样式部分

#### 定位

::: CTcode
```css{2}
.back-top {
  position: fixed;
  bottom: v-bind('offset[1] + "px"');
  z-index: 1000;
  cursor: pointer;
}
```
fixed 定位，永远贴在视口。
:::

::: CTcode
```css{3}
.back-top {
  position: fixed;
  bottom: v-bind('offset[1] + "px"');
  z-index: 1000;
  cursor: pointer;
}
```
Vue 3 css `v-bind` 语法，把运行时传入的 `prop` 注入 CSS，无需写行内 style。
:::

::: CTcode
```css
.back-top.pos-right {
  right: v-bind('offset[0] + "px"');
}
.back-top.pos-left {
  left: v-bind('offset[0] + "px"');
}
```
决定 right 或 left 偏移量，同样用 `v-bind(offset[0])`。
:::

#### 圆环+内圆

::: CTcode
```css
.progress-ring {
  width: v-bind('size + "px"');
  height: v-bind('size + "px"');
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
```
外环，`overflow: hidden` 保证圆锥渐变不溢出。
:::

::: CTcode
```css
.back-top-inner {
  border-radius: 50%;
  background: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  transition: all 0.3s ease;
}
.back-top-inner:hover {
  transform: scale(1.05) rotate(180deg);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}
```
白底圆，hover 放大 5% + 旋转 180°（箭头翻转）。
:::