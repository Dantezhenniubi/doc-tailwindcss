---
outline: [1,6]
---

# SSR和SSG

## 简单介绍
| 术语                           | 含义                                                                | 适用场景                                     |
| ------------------------------ | ------------------------------------------------------------------- | -------------------------------------------- |
| SSR \(Server\-Side Rendering\) | 在 Node\.js 服务器环境 预渲染页面（VitePress 仅在构建阶段使用 SSR） | 构建时生成静态 HTML，解决 SEO 和首屏性能问题 |
| SSG \(Static Site Generation\) | 通过 SSR 在构建时生成 纯静态 HTML 文件（VitePress 的默认模式）      | 文档、博客等无动态数据的站点                 |
| 构建阶段                       | 在 CI/CD（如 GitHub Actions）中运行 pnpm build 生成静态文件的阶段   | 部署到 GitHub Pages、Netlify 等静态托管服务  |

## SSR (Server-Side Rendering,服务端渲染) 介绍
你可以查看Vue官方文档[有关SSR的部分](https://cn.vuejs.org/guide/scaling-up/ssr#what-is-ssr)

### 核心概念
当用户请求一个网页时，服务器会实时运行应用程序代码（通常是 JavaScript，如 React, Vue, Angular），将组件渲染成完整的 HTML 页面，然后将这个完整的 HTML 页面发送给用户的浏览器。
### 工作流程
- 用户在浏览器中输入 URL 或点击链接。
- 浏览器向服务器发送页面请求。
- 服务器接收到请求。
- 服务器执行相关应用逻辑（可能包括从数据库或 API 获取数据）。
- 服务器运行前端框架（如 React/Vue）的代码，将组件树渲染成 HTML 字符串（这个过程发生在服务器上）。
- 服务器将生成的完整 HTML 页面（包含初始内容）发送回浏览器。
- 浏览器接收到 HTML 并立即显示（用户能看到内容）。
- 浏览器下载页面所需的 JavaScript 文件（React/Vue 等）。
- JavaScript 在浏览器中执行，接管页面（“注水”/Hydration），添加交互性，页面变为一个单页应用。

### 主要优点
- 更快的首屏加载速度 (FCP)： 用户能更快地看到内容（完整的 HTML），而不是等待所有 JS 下载执行完才看到空白或骨架屏。
- 更好的 SEO： 搜索引擎爬虫直接接收到完整的 HTML 内容，更容易理解和索引页面内容。对于依赖搜索引擎流量的网站至关重要。
- 更好的低端设备/慢网络体验： 即使用户的设备性能较差或网络很慢，服务器渲染好的 HTML 也能保证用户先看到内容。
- 统一的心智模型：你可以使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。

### 主要缺点
- 服务器负载更高： 每个页面请求都需要服务器执行渲染逻辑，对服务器 CPU 和资源要求更高，尤其是在高并发时。
- TTI (Time to Interactive) 可能延迟： 虽然用户看到内容快，但需要等待 JS 下载、执行并完成“注水”后，页面才能完全交互。如果 JS 很大，用户看到内容后可能暂时无法点击按钮等。
- 开发复杂性： 需要考虑服务器端兼容性（如 window、document 对象在 Node.js 环境不可用），数据获取方式（需要保证服务器和客户端都能获取），部署运维也更复杂（需要 Node.js 服务器环境）。

## SSG (Static Site Generation,静态站点生成) 介绍
### 核心概念
在应用构建阶段（部署之前），就运行应用程序代码，将每个页面预渲染成纯静态的 HTML 文件（以及相关的 CSS、JS、图片等）。这些文件随后被部署到一个简单的 Web 服务器（或 CDN）上。
### 工作流程
- 开发者编写代码（页面组件、数据获取逻辑）。
- 运行构建命令（如 npm run build）。
- 构建工具（如 Next.js, Gatsby, VuePress）会：
    - 分析路由，确定需要生成哪些页面。
    - 在构建时执行数据获取逻辑（从 API、数据库、文件系统等）。
    - 使用获取到的数据，运行前端框架代码，将每个页面组件渲染成静态 HTML。
    - 生成对应的 .html 文件以及所有必需的资源文件（JS, CSS, 图片等）。
- 将生成的 out 或 dist 文件夹部署到静态托管服务（Netlify, Vercel, GitHub Pages, S3 + CloudFront 等）。
- 用户请求页面时，服务器/CDN 直接返回预先生成好的静态 HTML 文件。
- 浏览器接收到 HTML 并立即显示。
- JS 下载执行后接管页面（Hydration），添加交互性。

### 主要优点
- 极致的性能： 静态文件可以直接从 CDN 边缘节点快速送达用户，加载速度极快（极佳的 FCP 和 TTI）。
- 极高的可扩展性和安全性： 只需要简单的静态文件服务器或 CDN，没有服务器运行时，能轻松应对高流量，攻击面也小。
- 优秀的 SEO： 和 SSR 一样，爬虫直接获取完整的静态 HTML 内容。
- 低成本： 静态托管通常非常便宜甚至免费。

### 主要缺点
- 构建时数据获取： 数据只在构建时获取一次。如果数据频繁变化，页面内容会过时，直到下次重新构建部署。
- 不适合高度动态/个性化内容： 为每个用户生成个性化页面（如用户仪表盘）在纯 SSG 下难以实现（需要结合客户端渲染或 SSR）。
- 大型站点构建时间长： 如果站点有成千上万个页面，每次构建生成所有 HTML 文件可能需要较长时间。

## 书写SSR友好的代码
可以查看[Vue官方文档有关SSR友好的部分](https://cn.vuejs.org/guide/scaling-up/ssr#writing-ssr-friendly-code)<br>
里面讲得确实比较详细了
后续会继续补充个人理解