---
outline: [2, 6]
tag: ['tailwindcss', '切换背景图']
---

# 切换背景图方案 {#切换背景图方案}
这里记录一些切换背景图的方案，实践中遇到的问题，以及解决办法。

事情是这样的：

我想用tailwindcss给网站设置背景图片，经过查阅官方文档发现正常来说语法是这样的`bg-[url('/path/to/image.jpg')]`
::: danger 疑问
但是我想使用变量来切换背景图怎么办？
:::
> Tailwind 的原理
用正则表达式匹配到所有
简单来说，Tailwind 是通过扫描特定文件(在 3.x 是你配置里限定的所有文件)
有效的 Tailwind Class，然后生成最终的 CSS 文件，仅此而已，就是这么简单,
也正因为是使用正则表达式，我们不能通过字符串拼接的方式添加 Class，比如：
`className={`bg-${color}-600 hover:bg-${color}-500 ...`}>`

很显然，`bg-[url('/path/to/image.jpg')]`中的`/path/to/image.jpg`是一个固定的值，硬编码，我们不能使用变量来替换它，tailwindcss并不会扫描变量的内容。<br>

只能使用变量到class的映射，即传递一整个class类名，比如：
`<button class={`${colorVariants[color]} ...`}>`

一开始，通过查阅社区，我发现一种并不是很优雅的方案，即使用原生内联样式style来传入变量：
::: CTcode
```vue{2}
<template>
  <div class="bg-cover bg-center" :style="{ backgroundImage: `url(${bgImage})` }">
    <!-- 内容 -->
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const bgImage = ref('/path/to/image.jpg')
</script>
```
:::

这种方式虽然实现了变量的映射，但是有一个问题，就是不能完全兼容tailwindcss的实用类，比如`bg-gradient-to-br from-sky-500 to-indigo-600`，因为只能拥有一个`backgroundImage`属性，所以不能同时使用渐变背景，如果你使用的是那种png纹理图又想上色就很麻烦了，是不是又得传一个内联属性。。。

因此经过实践，我总结了以下两种方案，本实现依赖状态管理库及其插件:

:::  CTcode 安装插件
```sh
pnpm add @nanostores/persistent nanostores @nanostores/vue
```
:::

## 方案一：使用tailwindcss的mask遮罩
### 背景图方法
创建一个store/bgStore.ts文件，并添加以下内容：
::: CTcode
```ts
// stores/bgStore.ts
import { persistentAtom } from '@nanostores/persistent';
import { atom } from 'nanostores';
import { computed } from 'nanostores';
import { withBase } from 'vitepress';

// 亮色背景
export const lightBgList = [
  { name: 'light-bg1', url: withBase('/LightBG/light-bg1.png') },
  { name: 'light-bg2', url: withBase('/LightBG/light-bg2.png') },
] as const;
//  暗色背景
export const darkBgList = [
  { name: 'dark-bg1', url: withBase('/DarkBG/dark-bg1.png') },
  { name: 'dark-bg2', url: withBase('/DarkBG/dark-bg2.png') },
] as const;

/* 各自持久化索引 */
export const $lightIdx = persistentAtom<number>('lightBgIdx', 0, {
  encode: String,
  decode: Number,
});

export const $darkIdx = persistentAtom<number>('darkBgIdx', 0, {
  encode: String,
  decode: Number,
});

// 创建一个 atom 来存储当前的暗色模式状态
export const $isDark = atom<boolean>(false);

/* 计算属性：返回完整 URL */
/* 响应式：自动跟随 isDark 返回当前应显示的背景 URL */
export const currentBgUrl = computed(
  [$lightIdx, $darkIdx, $isDark],
  (lightIdx, darkIdx, isDark) => {
    const list = isDark ? darkBgList : lightBgList;
    const idx = isDark ? darkIdx : lightIdx;
    return (list[idx]?.url ?? list[0].url) as string;
  }
);

/* 切换：只在当前色系内循环 */
export function nextBg(): void {
  const isDark = $isDark.value; // 读原子当前值，而不是直接用vitepress的useData的isDark
  const list = isDark ? darkBgList : lightBgList;
  const atom = isDark ? $darkIdx : $lightIdx;
  const next = (atom.get() + 1) % list.length;
  atom.set(next);
}

/* 预加载全部背景图 */
export function preloadAll(): void {
  lightBgList.forEach(({ url }) => {
    new Image().src = url;
  });
  darkBgList.forEach(({ url }) => {
    new Image().src = url;
  });
}
```
:::
### 明暗主题切换按钮
我们在切换黑暗模式时，背景图也需要同步切换，因此需要做些适配：

在调用vitepress自带的`toggle-appearance`方法后，更新nanostores的原子数据`$isDark`，由于`currentBgUrl`是计算属性且根据`$isDark`而更新，会自动更新背景图。

所以我们只需要更改`$isDark`的值即可达到在亮色模式和暗色模式两套背景图之间切换的效果。

因此，只需要在调用`toggle-appearance`方法后，把`$isDark`的值同步为vitepress的`useData().isDark`的值即可。
> 为什么要同步？
> 尝试过直接传vitepress的`isDark`值，结果是背景图不会在两套主题之间切换对应的套图，而是只有亮色模式下的套图。虽然没看过vitepress源码，但是我猜测大概率兼容不太好

:::CTcode 示例代码 
```vue{13-24}
<template>
  <div>
    <label class="switch" :title="switchTitle">
      <input type="checkbox" :checked="isDark" @change="toggleAppearance" />
      <span class="slider"></span>
    </label>
    <button class="fixed bottom-6 right-6 p-2 rounded-full bg-white/70" @click="nextBg()">
      <p>换背景</p>
    </button>
  </div>
</template>

<script lang="ts" setup>
import { inject, watchPostEffect, ref } from 'vue';
import { useData } from 'vitepress';
import { nextBg, $isDark } from '../store/bgStore';

const { isDark, theme } = useData();

const toggleAppearance = inject('toggle-appearance', () => {
  isDark.value = !isDark.value;
  $isDark.set(isDark.value); // 同步原子
  // nextBg(); // 打开后，切换主题时背景图片索引增加会切换
});

const switchTitle = ref('');

watchPostEffect(() => {
  switchTitle.value = isDark.value
    ? theme.value.lightModeSwitchTitle || 'Switch to light theme'
    : theme.value.darkModeSwitchTitle || 'Switch to dark theme';
});
</script>

<style scoped>
@reference "tailwindcss";
/* 组件容器样式 The switch - the box around the slider */
.switch {
  font-size: 1rem;
  position: relative;
  display: inline-block;
  width: 4em;
  height: 2em;
  margin: 0;
}

/* 隐藏原生复选框 Hide default HTML checkbox */
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* 滑块轨道样式 The slider */
.slider {
  position: absolute;
  cursor: pointer;
  inset: 0;
  background-color: #eee;
  transition: 0.4s;
  border-radius: 0.5em;
  box-shadow: 0 0.2em #dfd9d9;
}

/* 滑块按钮样式 */
.slider:before {
  position: absolute;
  content: '';
  height: 1.5em;
  width: 1.4em;
  border-radius: 0.3em;
  left: 0.3em;
  bottom: 0.7em;
  background-color: lightsalmon;
  transition: 0.4s;
  box-shadow: 0 0.4em #bcb4b4;
}

/* 交互效果 */
.slider:hover::before {
  @apply animate-pulse;
  box-shadow: 0 0.2em #bcb4b4;
  bottom: 0.5em;
}

input:checked + .slider:before {
  transform: translateX(2em);
  background: lightgreen;
}

/* 暗色模式适配 Dark mode specific styles */
.dark .slider {
  background-color: #6a6a6a;
  box-shadow: 0 0.2em #444;
}

.dark .slider:before {
  background-color: #ff7b54;
  box-shadow: 0 0.4em #222;
}

.dark input:checked + .slider:before {
  background: #4caf50;
}
</style>
```
:::
### 布局内使用
由于本方案实现方式是将背景图作为TailwindCSS的遮罩来达到将渐变色和png纹理图结合的效果，我们需要将响应式数据传给内联样式的mask属性。
::: CTcode
```vue
<div
  class="absolute inset-0 bg-gradient-to-br from-sky-500 to-indigo-600 mask-center pointer-events-none"
  :style="{ maskImage: `url(${bgUrl})` }"
></div>
```
:::
`const bgUrl = useStore(currentBgUrl);`是将`currentBgUrl`返回的背景URL经过'@nanostores/vue'的`useStore`方法转换为响应式数据，并赋值给对象`bgUrl`。
::: CTcode
```vue
<script setup>
import { useStore } from '@nanostores/vue';
// import { $bgUrl } from '../store/bgStore';
import { nextBg, preloadAll, currentBgUrl, $isDark } from '../store/bgStore';

import { watchPostEffect, onMounted } from 'vue';
import { useData } from 'vitepress';

const { isDark } = useData();
// 响应式背景地址
const bgUrl = useStore(currentBgUrl);

// 监听 isDark 的变化并更新到 bgStore
watchPostEffect(() => {
  $isDark.set(isDark.value);
});

onMounted(() => {
  // 预加载下一张背景图
  preloadAll();
});
</script>
```
:::

## 方案二：使用tailwindcss的自定义类提前定义好背景图路径，然后使用变量来切换类名
这是本项目正在使用也是我最推荐的方案。0 内联样式，0 字符串拼接
::: success 说一下大概思路
1. 提前定义好背景图路径的tailwindcss自定义类，这里依赖`@theme`和`@utility`
2. 使用nanostores状态管理库及其插件，定义两个对象来存储亮暗两套背景图的类名，定义两个原子对象来存储亮暗两套背景图的索引，定义一个原子对象来存储vitepress的亮暗状态用于逻辑判断
3. 使用计算函数根据亮暗状态和当前索引实时返回对应背景套图的类名，赋值给布局组件内的对象，使用该对象传递类名至`class`属性即可
4. 切换背景图的方法，先判断亮暗状态选定，再判断索引，最后更新对应索引
5. 预加载背景图，使用tailwindcss的`getComputedStyle`方法获取背景图类名

:::

### 自定义类
找到你的tailwindcss的CSS文件，添加自定义类
::: CTcode
```css
@theme {
    /* 亮色背景 */
    --bg-light1: url('/LightBG/light-bg1.png');
    --bg-light2: url('/LightBG/light-bg2.png');

     /* 暗色背景 */
     --bg-dark1: url('/DarkBG/dark-bg1.png'); 
     --bg-dark2: url('/DarkBG/dark-bg2.png');
}

@utility bg-light1 {
  background-image: var(--bg-light1);
}
@utility bg-light2 {
  background-image: var(--bg-light2);
}
@utility bg-dark1 {
  background-image: var(--bg-dark1);
}
@utility bg-dark2 {
  background-image: var(--bg-dark2);
}
```
:::

### 编写方法
首先安装好插件：
::: CTcode
```bash
pnpm add nanostores @nanostores/vue @nanostores/persistent
```
:::
在项目的store文件夹下创建一个`bgStore.ts`文件并导入需要的方法
::: CTcode
```ts
import { persistentAtom } from '@nanostores/persistent';
import { atom } from 'nanostores';
import { computed } from 'nanostores';
```
:::

创建亮暗两个状态的类名对象
::: CTcode
```ts
export const lightClasses = ['bg-light1', 'bg-light2'] as const;
export const darkClasses = ['bg-dark1', 'bg-dark2'] as const;
```
:::

使用`persistentAtom`创建持久化的原子对象，会存储到localstorage中
::: CTcode
```ts
export const $lightIdx = persistentAtom<number>('lightBgIdx', 0, {
  encode: String,
  decode: Number,
});

export const $darkIdx = persistentAtom<number>('darkBgIdx', 0, {
  encode: String,
  decode: Number,
});
```
:::
创建一个 atom 来存储当前的暗色模式状态
::: CTcode
```ts
export const $isDark = atom<boolean>(false);
```
:::
创建一个计算函数，根据当前的暗色模式状态和索引返回对应的类名
::: CTcode
```ts
export const currentBgClass = computed(
  [$lightIdx, $darkIdx, $isDark],
  (lightIdx, darkIdx, isDark) => {
    const list = isDark ? darkClasses : lightClasses;
    const idx = isDark ? darkIdx : lightIdx;
    return list[idx] ?? list[0];
  }
);
```
:::
创建一个切换背景图的方法，先判断当前亮暗状态，再判断索引，最后更新索引
::: CTcode
```ts
export function nextBg(): void {
  const isDark = $isDark.value;
  const list = isDark ? darkClasses : lightClasses;
  const atom = isDark ? $darkIdx : $lightIdx;
  const next = (atom.get() + 1) % list.length;
  atom.set(next);
}
```
:::
创建预加载的方法，使用tailwindcss的`getComputedStyle`方法获取背景图类名，然后使用`new Image().src`预加载。
详情可以看官方文档的部分：<br>
[升级指南](https://tailwindcss.com/docs/upgrade-guide#theme-values-in-javascript)<br>
[主题变量](https://tailwindcss.com/docs/theme#referencing-in-javascript)<br>

::: warning 值得注意
关于怎么知道预加载生效，如果你是谷歌浏览器，请F12打开开发者面板，然后在Network(网络)标签页中点击图片筛选请求。

别忘了取消开发者面板的**禁用缓存**选项！！！

如果生效，刷新页面，你会看到首先有预加载的图片（200请求），然后是第一张出现的背景图（304请求）。

Network 里「0 B / (disk cache) / 304」代表缓存命中
:::

::: CTcode
```js
let styles = getComputedStyle(document.documentElement);
let shadow = styles.getPropertyValue("--shadow-xl");
```
:::

完整代码如下：
::: CTcode
```ts
export function preloadAll(): void {
  // 直接读变量并立刻预加载
  lightClasses.forEach((c) => {
    const url = getComputedStyle(document.documentElement).getPropertyValue(
      `--bg-${c.replace('bg-', '')}`
    );
    if (url) {
      new Image().src = url;
    }
  });

  darkClasses.forEach((c) => {
    const url = getComputedStyle(document.documentElement).getPropertyValue(
      `--bg-${c.replace('bg-', '')}`
    );
    if (url) {
      new Image().src = url;
    }
  });
}
```
:::

### 在布局中使用
::: CTcode
- 首先引入需要的方法
```vue
<script setup>
import { useStore } from '@nanostores/vue';
import { nextBg, preloadAll, currentBgClass, $isDark } from '../store/bgStore';
import { watchPostEffect, onMounted } from 'vue';
import { useData } from 'vitepress';

const { isDark } = useData(); // 拿到vitepress的dark状态
const bgClass = useStore(currentBgClass); // 使用`useStore`方法将计算函数返回的类名转换成Ref响应式对象
// 监听 isDark 的变化并更新到 bgStore
watchPostEffect(() => {
  $isDark.set(isDark.value);
});

onMounted(() => {
  // 预加载下一张背景图
  preloadAll();
});
</script>
```
- 最后，我们在组件的模板中像这样来使用，使用```:class="`${bgClass}`"```动态传入类名：
```vue{3}
<template>
<!-- 纹理背景图 PNG（最底层） -->
  <div :class="`min-h-screen relative overflow-hidden bg-center ${bgClass}`">
    <!-- 渐变遮罩：只裁背景，不裁内容 -->
    <div class="absolute inset-0 bg-mask-container pointer-events-none" aria-hidden="true"></div>
    <!-- 内容层：完全正常 -->
    <div class="relative z-10">
    <!-- 你的内容 -->
    </div>
</template>
```
- 至此，以tailwindcss类名的方式动态传入背景的方式实现完毕，现在你可以无缝与tailwindcss的其它实用类一起使用。

::: tip
关于混合渐变色的实现方式，你只需外层背景相对定位，渐变色在内层绝对定位，然后使用你自定义的渐变类，注意调整透明度，下面是示例：
```vue{5}
<template>
<!-- 纹理背景图 PNG（最底层） -->
  <div :class="`min-h-screen relative overflow-hidden bg-center ${bgClass}`">
    <!-- 渐变遮罩：只裁背景，不裁内容 -->
    <div class="absolute inset-0 bg-mask-container pointer-events-none" aria-hidden="true"></div>
    <!-- 内容层：完全正常 -->
    <div class="relative z-10">
    <!-- 你的内容 -->
    </div>
</template>
<style scoped>
/* 背景蒙版渐变色 */
.bg-mask-container {
  @apply bg-gradient-to-br from-cyan-300/20 to-teal-400/20;

  @variant dark {
    @apply bg-gradient-to-br from-blue-300/20 to-purple-400/20;
  }
}
</style>
```
:::
:::

### 关于布局的一些补充
关于层叠的部分，我们来详细说明：
::: CTcode
```vue
<template>
<!-- 纹理背景图 PNG（最底层） -->
  <div :class="`min-h-screen relative overflow-hidden bg-center ${bgClass}`">
    <!-- 渐变遮罩：只裁背景，不裁内容 -->
    <div class="absolute inset-0 bg-mask-container pointer-events-none" aria-hidden="true"></div>
    <!-- 内容层：完全正常 -->
    <div class="relative z-10">
    <!-- 你的内容 -->
    </div>
</template>
```

```aria-hidden="true"```是一个WAI-ARIA属性，用于指示一个元素及其所有后代元素是否应该对辅助技术（如屏幕阅读器）隐藏。它会保持可见，但会把自己从无障碍API 中隐藏起来。对我们的无障碍页面优化很重要的一个特性，对于我们不想给展示给盲人的用户可以通过这个属性来隐藏内容。<br>
**注意：不能在具有交互性的地方使用！**<br>
`absolute` 必须配合定位属性（`inset-0`、`top-*`、`left-*` 等）才能「贴边」；
并且直接以「最近一层带有 `relative` / `absolute` / `fixed` / `sticky`」的父元素」为原点——这就是「层叠根」的概念。<br>
外层 `relative`	成为原点<br>
内层 `absolute inset-0`	以父盒子左上角为 0,0，正好铺满父盒子<br>
> 没有 inset-0 → 元素会停在「文档流原始位置」，不会贴边。

> 为什么内容层要设置`relative`?
遮罩层 `absolute`	低于内容（默认 z-index = auto）<br>
内容层 `relative z-10`	高于遮罩，不被裁切，点击正常<br>

如果不写 `relative`，`z-10` 不会生效，内容就可能会被遮罩盖住。
:::
我们来思考一些问题:
::: info 问题
absolute绝对定位既然是脱离文档流，是不是以HTML根元素（最外层元素）进行定位？
:::
❌ **1. 「absolute 脱离文档流，是以 HTML 根元素定位」——错误**<br>
**`absolute` 的定位原点不是 `<html>`，而是「最近一层带有定位的祖先元素(包括父元素)」**（`relative` / `absolute` / `fixed` / `sticky`）。<br>
如果**所有祖先都是 `static`**，才会回退到**视口（不是 `<html>`）**。<br>
✅ 正确说法：<br>
> **absolute 以「最近非 static 祖先」为原点；全是 static 时以视口为原点。**<br>
::: info 问题
relative相对定位，是以最近的一层父元素进行定位，那我最外层的div标签是不是使用absolute也有相同的效果？
:::
❌ **2. 「最外层 div 用 absolute 也有相同效果」——错误**<br>
**最外层 div 默认是 static，不会成为原点；**<br>
你给它写 absolute 反而让它**脱离文档流、不占空间，不会给子元素提供原点**。<br>
✅ 正确做法：<br>
想给整个页面当原点，**给最外层 div 写 relative（零偏移），不要写 absolute或者static**。<br>
比如你给最外层 div 写了relative，那你内容层使用absolute或relative 都是以这个最外层div为原点，区别在于是否受文档流影响。<br>


::: info 问题
标签设置了static，是不是该元素任何类似inset-0的定位都会失效？
:::
✅ **3. 「static 下 inset-0 失效」——完全正确**<br>
static 元素不能设 inset-0 / top / left，写了也无效——这是 CSS 标准。<br>

::: info 问题
最外层div使用了static，那我内容层使用relative还是absolute是不是都一样？
:::
❌ **4. 「最外层 static，内容层用 relative 还是 absolute 都一样」——错误**<br>
最外层 static 时，relative 和 absolute 都以视口为原点，区别在于是否脱离文档流，脱离之后不受其它元素影响。<br>
::: success 总结
- **static元素不吃inset这种定位属性，并且该元素将不会作为absolute绝对定位子元素的位置参考**
- **relative的作用就是用来作为新的层叠上下文的根，不仅能给子元素提供参考，也能设置z-index层级** <br>
> relative = 「层叠开关」+ 「定位原点」<br>
> 不写 top/left 时，只用来「能设 z-index」<br>
> 「遮罩膜、弹窗、抬层级」→ 最外层写 relative（零偏移）<br>
> 「贴边、全覆盖、悬浮」→ 子元素写 absolute + inset-0 <br>